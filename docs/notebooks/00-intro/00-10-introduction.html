<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Summary – The Data Mage</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The Data Mage</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <span class="nav-link">
<span class="menu-text">Home</span>
    </span>
  </li>  
  <li class="nav-item">
    <span class="nav-link">
<span class="menu-text">About</span>
    </span>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notebooks\02-draft-data\02-00-draft-data-intro.html"> 
<span class="menu-text">Set Analysis</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meehljd/mtg-modeling"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/meehl/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link active" data-scroll-target="#table-of-contents"><span class="header-section-number">1</span> Table of Contents</a></li>
  <li><a href="#python" id="toc-python" class="nav-link" data-scroll-target="#python"><span class="header-section-number">2</span> Python</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">3</span> Introduction</a></li>
  <li><a href="#data-science" id="toc-data-science" class="nav-link" data-scroll-target="#data-science"><span class="header-section-number">4</span> Data Science</a>
  <ul class="collapse">
  <li><a href="#card-scope" id="toc-card-scope" class="nav-link" data-scroll-target="#card-scope"><span class="header-section-number">4.1</span> Card Scope</a></li>
  <li><a href="#play-format-scope" id="toc-play-format-scope" class="nav-link" data-scroll-target="#play-format-scope"><span class="header-section-number">4.2</span> Play Format Scope</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Summary</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>An introduction to the entire project.</p>
<section id="table-of-contents" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Table of Contents</h1>
<p>Refer to the <a href="00-00-project-table-of-contents.ipynb">Project ToC</a> file for the table of contents for each notebook in the project.</p>
<hr>
</section>
<section id="python" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Python</h1>
<p>Refer to the <a href="../../README.md">README.md</a> for the python environment setup.</p>
<hr>
</section>
<section id="introduction" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Introduction</h1>
<p>This project is an exploration of applying data science to Magic: The Gathering (MTG), a collectible card game known for its popularity, long history, and intricate gameplay. MTG offers a wealth of data and countless opportunities for analysis.</p>
<p>Although I’m not an MTG expert, I played briefly in 1999-2000 and recently returned to the game after my son became interested. This project is a way for me to deepen my understanding of MTG and provide insights that others might find useful.</p>
<p>I’ll analyze three main aspects of MTG: <strong>gameplay</strong>, <strong>collecting</strong>, and <strong>economics</strong>.</p>
<p>Given the complexity of gameplay, my analysis will cover various perspectives: aggregate win rates, micro-level decisions like combat resolution and mulligan choices, and evaluations of components such as card mana efficiency. We will also explore the <strong>metagame</strong>, including deck building, play formats, and drafting strategies</p>
<p>The collecting aspect of MTG is vast, with nearly 100,000 cards printed over the game’s history. I’ll examine this by looking into aspects like the probability distributions of collector booster packs.</p>
<p>Finally, the economics of MTG, particularly the secondary market for singles, is of great interest to me. I’ll focus on predicting card prices and analyzing price trends for new sets.</p>
<hr>
</section>
<section id="data-science" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Data Science</h1>
<p>MTG can be fodder for may aspects data science. Here is a sampler of concepts I would like to explore: <strong>Regression:</strong> Predict card’s expected mana cost given its attributes and keywords. - <strong>LLMs:</strong> Generate numeric representations from card descriptions with encoder LLMs. Use representations for predictive tasks. - <strong>Network Science:</strong> Bipartite graphs of deck-card relationships. Identify communities in card one-mode projection. - <strong>Graph Neural Networks:</strong> Predict deck win rate with given card compositions. - <strong>Bayesian Inference:</strong> Posterior distribution of a booster pack’s value given the pack composition and secondary market prices. - <strong>Time-Series Analysis:</strong> Predict card price on secondary market <span class="math inline">\(d\)</span> days after set release. - <strong>Hidden Markov Models:</strong> Estimation of board state. For example, estimate the states from <a href="https://magic.wizards.com/en/news/feature/quadrant-theory-2014-08-20">Quadrant Theory</a>. These states are ‘opening’, ‘parity’, ‘winning’, or ‘losing’ state. - <strong>Reinforcement Learning:</strong> Maximize the outcome of combat stage, given the board state of potentially attacking and defending creatures. - <strong>Optimization</strong>: Optimize win rate of a deck, given constraints such as maximum market cost or number of mythic rares. - <strong>Game Theory</strong>: For mulligans, calculate the expected value of hands using utility theory.</p>
<hr>
<section id="card-scope" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="card-scope"><span class="header-section-number">4.1</span> Card Scope</h2>
<section id="otj-set-description" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="otj-set-description"><span class="header-section-number">4.1.1</span> OTJ Set Description</h3>
<p>To keep the problem space tractable, I’ll limit the analysis to the <a href="https://mtg.fandom.com/wiki/Outlaws_of_Thunder_Junction">Outlaws of Thunder Junction</a> (OTJ) set, which was released on April 19, 2024.</p>
<p>The set contains 276 regular cards comprised of:</p>
<ul>
<li>91 Commons</li>
<li>100 Uncommons</li>
<li>60 Rares</li>
<li>20 Mythic rares</li>
<li>5 Basic lands</li>
</ul>
<p>Additional “booster fun” cards include: - 13 Showcase “Wanted Poster” cards - 60 Extended Art cards - 13 Borderless cards - 6 Bundle Basics lands - 7 Promos</p>
<p>For game play analysis, I’ll focus on the 276 regular cards. For market analysis, I’ll include the booster fun cards, as the scarcity and desirability of these cards may affect the secondary market prices and will be interesting to explore.</p>
</section>
<section id="card-data-sources" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="card-data-sources"><span class="header-section-number">4.1.2</span> Card Data Sources</h3>
<p>I’ll use the card data generously made available by the tireless folks at the open-source project <a href="https://mtgjson.com/">MTGJSON</a>. MTGJSON provides a comprehensive database of MTG cards, including card attributes, card text, and card prices. The data is available in JSON format, which I’ll convert to a pandas DataFrame for analysis.</p>
<p>MTGJSON sources a lot of data from <a href="https://scryfall.com/docs/api">Scryfall</a>, which has an excellent webapp for exploring MTG card data.</p>
<p>MTGJSON sources the booster pack composition data from. The source code provided by <a href="https://github.com/taw">taw</a> on <a href="https://github.com/taw/magic-search-engine?tab=readme-ov-file">github</a> contains estimated booster pack composition probabilities. He also provides a webapp at <a href="https://mtg.wtf/">mtg.wtf</a>. Note that booster pack composition is proprietary information of Wizards of the Coast, and the above probabilities are estimates.</p>
<p>See the <a href="../../notebooks/01-mtgjson-data/01-00-mtgjson-data-intro.html">01-00-mtgjson-data-intro</a> notebook for more details on the data sources.</p>
</section>
</section>
<section id="play-format-scope" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="play-format-scope"><span class="header-section-number">4.2</span> Play Format Scope</h2>
<section id="limited-play" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="limited-play"><span class="header-section-number">4.2.1</span> Limited Play</h3>
<p>For game play, I will look at limited formats, such as Draft and Sealed Deck. Constructed formats, such as Standard, Modern, and Legacy, are out of scope for now. This is due to the complexity of the metagame and the vast number of cards available for deck construction.</p>
<p>Draft play also allows us to study three types of player skill. First, there is the skill of drafting the best cards from the draft pool based on one’s currently drafted cards. Second, there is the skill of deck construction from the drafted cards. Third, there is the skill of playing the deck in a tournament setting.</p>
<p>Sealed and constructed formats are also interesting, but exclude the drafting skill. Constructed formats also require a deep understanding of the metagame, which is out of scope for now.</p>
</section>
<section id="mtg-arena-draft" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="mtg-arena-draft"><span class="header-section-number">4.2.2</span> MTG Arena Draft</h3>
<p>I will specifically look at the Draft format on <a href="https://magic.wizards.com/en/mtgarena">MTG Arena</a>. MTG Arena is an online platform for playing MTG. The Draft format on MTG Arena is a popular way to play limited MTG. In the Draft format, players open booster packs and pick one card from the pack. The remaining cards are passed to the next player. This process continues until all cards are picked. Players then construct a deck from the picked cards and play a tournament with the constructed deck.</p>
<p>MTG Arena offers several Draft formats. I will focus on the <a href="https://magicarena.fandom.com/wiki/Premier_Draft">Premier Draft</a> format, which is a best-of-one (Bo1) format. In the Premier Draft format, players draft against other players in a pod of 8 players. Players play a tournament with the drafted deck. Players play until they reach 7 wins or 3 losses. Players have a sideboard and are allowed to change the deck composition between games.</p>
<p>Other formats include Quick Draft, which also Bo1, but the drafting process in against a pool of bots, and play is against players with independent draft pools. Traditional Draft is a best-of-three (Bo3) format. Sealed Deck is another limited format where players open 6 booster packs and construct a deck from the opened cards. These are out of scope for now.</p>
</section>
<section id="draft-play-data-sources" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="draft-play-data-sources"><span class="header-section-number">4.2.3</span> Draft Play Data Sources</h3>
<p>For draft play, I will used data from <a href="https://www.17lands.com/public_datasets">17lands</a>. They compile data from their user base to provide draft pick data. The data includes the draft pick order, the cards picked, and the win rate of the deck.</p>
<p>See the <a href="../../notebooks/02-draft-data/02-00-draft-data-intro.html">02-10-draft-data-intro</a> notebook for more information on the draft data.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<footer style="text-align: center; padding: 10px 0; font-size: 0.8em; color: #666;">
    © <span id="current-year"></span> Joshua Meehl. All rights reserved. This website is unofficial Fan Content permitted under the Fan Content Policy of Wizards of the Coast. It is not
    sponsored, endorsed, or affiliated with Wizards of the Coast.
</footer>
<script>
    const baseYear = 2024;
    const currentYear = new Date().getFullYear();
    const displayYear = currentYear > baseYear ? `${baseYear}-${currentYear}` : `${baseYear}`;
    document.getElementById('current-year').textContent = displayYear;
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>